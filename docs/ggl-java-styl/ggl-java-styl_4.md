# 格式

## 格式

**术语说明**：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1 节)。

# 大括号

### 4.1 大括号

# 使用大括号(即使是可选的)

#### 4.1.1 使用大括号(即使是可选的)

大括号与`if, else, for, do, while`语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。

# 非空块：K & R 风格

#### 4.1.2 非空块：K & R 风格

对于非空块和块状结构，大括号遵循 Kernighan 和 Ritchie 风格 ([Egyptian brackets](http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html)):

*   左大括号前不换行
*   左大括号后换行
*   右大括号前换行
*   如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是 else 或逗号，则不换行。

示例：

```java
return new MyClass() {
  @Override public void method() {
    if (condition()) {
      try {
        something();
      } catch (ProblemException e) {
        recover();
      }
    }
  }
}; 
```

4.8.1 节给出了 enum 类的一些例外。

# 空块：可以用简洁版本

#### 4.1.3 空块：可以用简洁版本

一个空的块状结构里什么也不包含，大括号可以简洁地写成`{}`，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。

示例：

```java
void doNothing() {} 
```

# 块缩进：2 个空格

### 4.2 块缩进：2 个空格

每当开始一个新的块，缩进增加 2 个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见 4.1.2 节中的代码示例)

# 一行一个语句

### 4.3 一行一个语句

每个语句后要换行。

# 列限制：80 或 100

### 4.4 列限制：80 或 100

一个项目可以选择一行 80 个字符或 100 个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。

例外：

1.  不可能满足列限制的行(例如，Javadoc 中的一个长 URL，或是一个长的 JSNI 方法参考)。
2.  `package`和`import`语句(见 3.2 节和 3.3 节)。
3.  注释中那些可能被剪切并粘贴到 shell 中的命令行。

# 自动换行

### 4.5 自动换行

**术语说明**：一般情况下，一行长代码为了避免超出列限制(80 或 100 个字符)而被分为多行，我们称之为自动换行(line-wrapping)。

我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。

> > Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)

# 从哪里断开

#### 4.5.1 从哪里断开

自动换行的基本准则是：更倾向于在更高的语法级别处断开。

1.  如果在`非赋值运算符`处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与 Google 其它语言的编程风格不同(如 C++和 JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&（`<T extends Foo & Bar>`)，catch 块中的管道符号(`catch (FooException | BarException e`)
2.  如果在`赋值运算符`处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于`foreach`语句中的分号。
3.  方法名或构造函数名与左括号留在同一行。
4.  逗号(,)与其前面的内容留在同一行。

# 自动换行时缩进至少+4 个空格

#### 4.5.2 自动换行时缩进至少+4 个空格

自动换行时，第一行后的每一行至少比第一行多缩进 4 个空格(注意：制表符不用于缩进。见 2.3.1 节)。

当存在连续自动换行时，缩进可能会多缩进不只 4 个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。

第 4.6.3 水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。

# 空白

### 4.6 空白

# 垂直空白

#### 4.6.1 垂直空白

以下情况需要使用一个空行：

1.  类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。
    *   **例外**：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。
2.  在函数体内，语句的逻辑分组间使用空行。
3.  类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。
4.  要满足本文档中其他节的空行要求(比如 3.3 节：import 语句)

多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。

# 水平空白

#### 4.6.2 水平空白

除了语言需求和其它规则，并且除了文字，注释和 Javadoc 用到单个空格，单个 ASCII 空格也出现在以下几个地方：

1.  分隔任何保留字与紧随其后的左括号(`(`)(如`if, for catch`等)。
2.  分隔任何保留字与其前面的右大括号(`}`)(如`else, catch`)。
3.  在任何左大括号前(`{`)，两个例外：
    *   `@SomeAnnotation({a, b})`(不使用空格)。
    *   `String[][] x = foo;`(大括号间没有空格，见下面的 Note)。
4.  在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：
    *   类型界限中的&(`<T extends Foo & Bar>`)。
    *   catch 块中的管道符号(`catch (FooException | BarException e`)。
    *   `foreach`语句中的分号。
5.  在`, : ;`及右括号(`)`)后
6.  如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。
7.  类型和变量之间：List <string class="calibre21">list。</string>
8.  数组初始化中，大括号内的空格是可选的，即`new int[] {5, 6}`和`new int[] { 5, 6 }`都是可以的。

> > Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。

# 水平对齐：不做要求

#### 4.6.3 水平对齐：不做要求

**术语说明**：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。

这是允许的(而且在不少地方可以看到这样的代码)，但 Google 编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。

以下示例先展示未对齐的代码，然后是对齐的代码：

```java
private int x; // this is fine
private Color color; // this too

private int   x;      // permitted, but future edits
private Color color;  // may leave it unaligned 
```

> > Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了 reviewer 的工作并且可能导致更多的合并冲突。

# 用小括号来限定组：推荐

### 4.7 用小括号来限定组：推荐

除非作者和 reviewer 都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个 Java 运算符优先级表。

# 枚举类

### 4.8 具体结构

# 枚举类

#### 4.8.1 枚举类

枚举常量间用逗号隔开，换行可选。

没有方法和文档的枚举类可写成数组初始化的格式：

```java
private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS } 
```

由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。

# 变量声明

#### 4.8.2 变量声明

##### 4.8.2.1 每次只声明一个变量

不要使用组合声明，比如`int a, b;`。

##### 4.8.2.2 需要时才声明，并尽快进行初始化

不要在一个代码块的开头把局部变量一次性都声明了(这是 c 语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。

# 数组

#### 4.8.3 数组

##### 4.8.3.1 数组初始化：可写成块状结构

数组初始化可以写成块状结构，比如，下面的写法都是 OK 的：

```java
new int[] {
  0, 1, 2, 3
}

new int[] {
  0,
  1,
  2,
  3
}

new int[] {
  0, 1,
  2, 3
}

new int[]
    {0, 1, 2, 3} 
```

##### 4.8.3.2 非 C 风格的数组声明

中括号是类型的一部分：`String[] args`， 而非`String args[]`。

# switch 语句

#### 4.8.4 switch 语句

**术语说明**：switch 块的大括号内是一个或多个语句组。每个语句组包含一个或多个 switch 标签(`case FOO:`或`default:`)，后面跟着一条或多条语句。

##### 4.8.4.1 缩进

与其它块状结构一致，switch 块中的内容缩进为 2 个空格。

每个 switch 标签后新起一行，再缩进 2 个空格，写下一条或多条语句。

##### 4.8.4.2 Fall-through：注释

在一个 switch 块内，每个语句组要么通过`break, continue, return`或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是 OK 的(典型的是用`// fall through`)。这个特殊的注释并不需要在最后一个语句组(一般是`default`)中出现。示例：

```java
switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
    // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
} 
```

##### 4.8.4.3 default 的情况要写出来

每个 switch 语句都包含一个`default`语句组，即使它什么代码也不包含。

# 注解(Annotations)

#### 4.8.5 注解(Annotations)

注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第 4.5 节，自动换行)，因此缩进级别不变。例如：

```java
@Override
@Nullable
public String getNameIfPresent() { ... } 
```

**例外**：单个的注解可以和签名的第一行出现在同一行。例如：

```java
@Override public int hashCode() { ... } 
```

应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：

```java
@Partial @Mock DataLoader loader; 
```

参数和局部变量注解没有特定规则。

# 注释

#### 4.8.6 注释

##### 4.8.6.1 块注释风格

块注释与其周围的代码在同一缩进级别。它们可以是`/* ... */`风格，也可以是`// ...`风格。对于多行的`/* ... */`注释，后续行必须从`*`开始， 并且与前一行的`*`对齐。以下示例注释都是 OK 的。

```java
/*
 * This is          // And so           /* Or you can
 * okay.            // is this.          * even do this. */
 */ 
```

注释不要封闭在由星号或其它字符绘制的框架里。

> > Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用`/* ... */`。

# Modifiers

#### 4.8.7 Modifiers

类和成员的 modifiers 如果存在，则按 Java 语言规范中推荐的顺序出现。

```java
public protected private abstract static final transient volatile synchronized native strictfp 
```